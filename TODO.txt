
Для описания операторов используется синтаксис типа
[X][Y]+
где [] обозначают выражение или простой объект.
Если же в описании стоит () то это простой объект (или имя объекта).

например
[X](Y)==

описание оператора, это его сигнатура и она определяет число аргументов у оператора.

Помимо сигнатуры оператор еще есть правила связи операторов, которые позволяют делать преобразования
по правилам.

Например, перестоновочный закон для оператора сложения выглядит так:
[x] [y] + [y] [x] + ==

Имя переменной в скобках рассматривается только в пределах одной строки.

если имя стоит в кавычках "", то это означает, для простого объекта, что берется его имя.
Если же объект это выражение, то сначала вычисляется значение этого объекта, а потом берется его имя.

Склеивание имен. Если нам необходимо склеить два имени объекта, то запись будет выглядеть "[X][Y]"

Вычитание имен. Если мы хотим разделить имя на 2 части, часть из которых известна, то нужно воспользоваться правилом

(X) (Y) -@
"[x][y]" "[y]" -@ "[x]" ==

оператор -@ отрезает имя справа, если оно имеется.

можно так же определить оператор -/. который разделяет имя на 2 части

(X) (Y) -/.
"[X][Y]" "[Y]" -/. "[X]" "[Y]" ==

Если имя объекта не известно, но нужно отделить один символ от имени объекта, нужно использовать имя "?"
для 2 символов "??" и так дале.

Если нужно повторить операцию несколько раз, то для этого нужно использовать операцию

x[N], где N воспринимается как целое число и при этом может быть использован как итератор в выражении.

F "?" -/. x[5] R ==

Это уравнение отрезает от имени 5 символов.
Для определения нового имени оператора из уже существующих можно использовать {} например

"[X]" "?" -/. x[N] {R5} ==

Определили новый оператор R5 который отрезает N символов от имени. 
Ну и так далее.

По сути дела интерпретатор должен находить определение оператора и уметь применять его. При этом применение будет делаться в случайной последовательности, а вектор, определяющий направление вычисления - это избавление от всех операторов, или сведение их числа к минимуму.

Нужен так же оператор счета параметров.
Какие-то операторы нужно будет ввести до того как их использовать, то есть это будут встроенные операторы
и они будут лежать в основе языка.


То есть интерпретатор должен различать:
1) сигнатуру функции
2) правила преобразования понятний (переменных)
3) связи или ограничения (на параметры) (определения)
4) функции более высокого порядка, построенные на более мелких или встроенных функциях и операторах.
5) Правила преобразования выражений (типа сочетательный закон и т.д.) или интерпретация.

Сама по себе программа должны представлять собой список правил, действий и отношений, который будет случайным образом преобразовывать входные отношения и достраивать оригинальный список.

Алгоритм движка должен быть таким:

находим терм уравнения (или группы уравнений) которую нужно решить и производим подстановку определения, действия или отношений 
производим оценку преобразования. если подобная комбинация уже встречалась, то она не принимается.

Если после некоторого числа операций невозможно уменьшить число операторов или все варианты приводят к ранее известными, то вычисление останавливается.


Встроенные операторы это "=="
смысл его означает тождественное преобразование одного выражения в другое.

Другой встроенный оператор "=>" означает однозначное преобразование одного выражения в другое.
==============

Для начала нужно вделять сигнатуры функции. В сигнатуре нужно различать аргументы, которые могут быть в квадратных скобках



