
Для описания операторов используется синтаксис типа
[X][Y]+
где [] обозначают выражение или простой объект.
Если же в описании стоит () то это простой объект (или имя объекта).

например
[X](Y)==

описание оператора, это его сигнатура и она определяет число аргументов у оператора.

Помимо сигнатуры оператор еще есть правила связи операторов, которые позволяют делать преобразования
по правилам.

Например, перестоновочный закон для оператора сложения выглядит так:
[x] [y] + [y] [x] + ==

Имя переменной в скобках рассматривается только в пределах одной строки.

если имя стоит в кавычках "", то это означает, для простого объекта, что берется его имя.
Если же объект это выражение, то сначала вычисляется значение этого объекта, а потом берется его имя.

Склеивание имен. Если нам необходимо склеить два имени объекта, то запись будет выглядеть "[X][Y]"

Вычитание имен. Если мы хотим разделить имя на 2 части, часть из которых известна, то нужно воспользоваться правилом

(X) (Y) -@
"[x][y]" "[y]" -@ "[x]" ==

оператор -@ отрезает имя справа, если оно имеется.

можно так же определить оператор -/. который разделяет имя на 2 части

(X) (Y) -/.
"[X][Y]" "[Y]" -/. "[X]" "[Y]" ==

Если имя объекта не известно, но нужно отделить один символ от имени объекта, нужно использовать имя "?"
для 2 символов "??" и так дале.

Если нужно повторить операцию несколько раз, то для этого нужно использовать операцию

x[N], где N воспринимается как целое число и при этом может быть использован как итератор в выражении.

F "?" -/. x[5] R ==

Это уравнение отрезает от имени 5 символов.
Для определения нового имени оператора из уже существующих можно использовать {} например

"[X]" "?" -/. x[N] {R5} ==

Определили новый оператор R5 который отрезает N символов от имени. 
Ну и так далее.

По сути дела интерпретатор должен находить определение оператора и уметь применять его. При этом применение будет делаться в случайной последовательности, а вектор, определяющий направление вычисления - это избавление от всех операторов, или сведение их числа к минимуму.

Нужен так же оператор счета параметров.
Какие-то операторы нужно будет ввести до того как их использовать, то есть это будут встроенные операторы
и они будут лежать в основе языка.


То есть интерпретатор должен различать:
1) сигнатуру функции
2) правила преобразования понятний (переменных)
3) связи или ограничения (на параметры) (определения)
4) функции более высокого порядка, построенные на более мелких или встроенных функциях и операторах.
5) Правила преобразования выражений (типа сочетательный закон и т.д.) или интерпретация.

Сама по себе программа должны представлять собой список правил, действий и отношений, который будет случайным образом преобразовывать входные отношения и достраивать оригинальный список.

Алгоритм движка должен быть таким:

находим терм уравнения (или группы уравнений) которую нужно решить и производим подстановку определения, действия или отношений 
производим оценку преобразования. если подобная комбинация уже встречалась, то она не принимается.

Если после некоторого числа операций невозможно уменьшить число операторов или все варианты приводят к ранее известными, то вычисление останавливается.


Встроенные операторы это "=="
смысл его означает тождественное преобразование одного выражения в другое.

Другой встроенный оператор "=>" означает однозначное преобразование одного выражения в другое.
==============

Для начала нужно вделять сигнатуры функции. В сигнатуре нужно различать аргументы, которые могут быть в квадратных скобках.

Что должна отражать сигнатура? Количество аргументов, которые могут быть или простыми именами или выражениями.
Может ли сигнатура функции быть типа такой:

[ X [Y] ] * и если может быть, то что она значит? Скорее всего сигнатура может быть немного другой, типа

[ X [Y] op1 ] op2   Но в таком случае непонятно зачем нужно описывать сигнатуру функции op1.

Поэтому сигнатуры могут описывать только 
1) простые параметры, которые должны браться в круглые скобки (X)

2) параметры, которые могут быть составными должны браться в квадратные скобки [Y]

3) Параметр простой, если он является вычисленным и представляет собой только имя.

4) Имя в свою очередь может быть представлено как результат вычисления некого выражения.

Все операции производятся над именами, просто составной параметр состоит из простых имен разделенных пробелами.

параметр или имя - это некое сочетание символов, которое имеет нулевун сигнатуру.
нулевая сигнатура описывается как 
[0] a

Обычно не нужно описывать простые параметры, поскольку они представляют собой само название. Величина параметра это и есть его имя.

Сам параметр (его имя) не несет никакого смысла, если не определены отношения этого параметра с другими параметрами.

Операции имеют сигнатуру, которая может быть определена через последовательность параметров. Эта сигнатура нужна для того, чтобы правильно парсить выражение.

Иногда для манипуляций с именем можно задать переменную, то есть переменная по сути дела может быть разименована, разыменование и есть вычисление ее имени из остальных отношений.

Переменные нужно как-то обозначить, их нужно отличать от простых имен.

Так как простые переменные могут содержать любые символы, то переменные должны содержать некий редко используемый символ, который может так же содержаться в имени, но как ескейп последовательность.

Например, если переменная должна заканчиваться на знак ? , то как определить например имя параметра использующее знак вопроса?

Так как я буду использовать все те символы, которые можно встретить на печати.

Для того, чтобы отличить переменную от константы после нее будет ставится модификатор "?"

То есть переменная X отличается от понятия X только тем, что после переменной стоит вопрос

[X] ?

Есть сигнатура переменной.

Если мы хотим задать выражение, то оно записывается как

2 4 + 5 * 20 / X ? ==

то есть по человечески это означает уравнение X = (2+4) *5 /20
для того, чтобы вычислить значение переменной нужно задать уравнение

X ?

А в уравнениях нужно просто использовать модификатор значения, который означает вычисление переменной и замену ее вычисленным выражением.
Такой модификатор будет !

правила действий такие 

[X] ? ! [X] ==

Что означает тогда правило если оно применено к простой переменной?

[X] !  

Пусть оно выводит определение параметра
Например:

если определено
 	3 2 + 5 ==
то 
5 ! выведет определение

3 2 +

и наоборот, 

3 2 + ! выведет
5

------------------------------------------------------------
2) правила преобразования понятний (переменных)
3) связи или ограничения (на параметры) (определения)

переменные, или имена преобразуются по определениям.

например,

2 1 + 3 ==
3 1 + 4 ==

Эти два определения показывают как соотносятся имена. согласно правилам можно делать подстановку одного имени в другое имя
если такое имя имеется (есть его определение).

Замена будет осуществлятся ненаправленно с целью получить как можно меньшее количество имен и операторов в определении.
Если такого получить не удается за определенное количество итерраций, то связь оказывается невычислимой.

Невычислимая связь переменных может быть включена в доверенный базис и использоваться для других вычислений. 
Если не существует доверия к отношению, то оно не используется в вычислениях.

Переменные используются в вычислениях в случае, если имеется некое составное имя, которое нужно вычислить.
Результат, как правило, используется в других вычислениях.

Надо заметить, что переменные, которые стоят в определении не имеют ничего общего с непосредственным процессом вычисления.
Они просто определяют различные переменные.

---------------------------------------------------------------
5) Правила преобразования выражений (типа сочетательный закон и т.д.) или интерпретация.

операторы могут находится в определенной комбинации, и если обнаружен такой паттерн, то может быть применена комбинация.

Пример, 

[X] [Y] + [Z] + [X] [Y] [Z] + + ==

сочетательный закон может быть применен к выражению.

--------------------------------------------------------------

Для проведения вычислений будет использоваться генератор случайных чисел, при этом вероятность преобразования в сторону 
с увеличением числа переменных и операторов будет меньше, чем вероятность преобразования с уменьшением числа переменных
и операторов.

Это позволит проводить редукцию выражений, если такая возможность существует.
Идея с лентой вычслений тоже хорошая, но она пригодится в случае, если требутся полный перебор решений.

В процессе преобразований будут появляться производные связи, которые могут быть сохранены как правдоподобные, если они 
выведены из истинного набора отношений.

При загрузке отношений и преобразований будет составляться сумма выражений и операторов, с целью определить вероятность 
направления преобразования.

Например
 2 1 + 3 ==
 имеем 2 переменные и 1 оператор с одной стороны и 1 переменную с другой стороны. То есть соотношение 3:1.
 Вероятность будет смещена в сторону преобразования от 3 к 1, например 0.6 к 0.4
Это соотношение нужно подобрать экспериментально на основе сходимости.

---------------------------------------------

1) Грузим правила, проверяем синтаксис и считаем баланс.
2) Составляем сигнатуры операторов, это нужно чтобы парсить синтаксис.
3) Получаем выражение которое нужно вычислить.
4) В полученном выражении выделяем символы и операторы. 
5) Если встречаются неизвестные операторы то предлагается ввести сигнатуру операторов, можно так же вводить
правила преобразования.
6) Если не удается провести преобразование, но ввод преобразуется к такому формату, в котором выделяется неопределенный символ
Или производится запрос на его определение.
7) если вводится ошибочное отношение и вычисления приходят к противоречию или синонимичным выводам, то они так же запрашиваются
для подтверждения.

===================================================
Как лучше делать парсинг выражений?

Вполне возможно, что грузить предложения лучше в подобие стека, где одна ячейка занимает
один оператор с выражением.

И правила так же хранить в таком виде, чтобы можно было производить замену фрагмента стека частично. Вложенные выражения хранить отдельно, создавать несколько стеков.

Например выражение:

2 3 + 5 * 
можно разбить на 2 стека, в котором операции над аргументами производить независимо.
В одном стеке будет выражение 2 3 + , а в другом X 5 *. Стек целиком может рассматриваться как переменная. получается, что каждая переменная будет содержать только один оператор и несколько аргументов.

Сигнатура оператора по сути представляет собой сколько аргументов должно быть зарезервировано.
применение правил преобразования для одного оператора будет делаться тоже просто, потому, что
это означает лишь модификацию содержимого одного стека.

По сути дела, каждая переменная это стек. В кажом стеке 1 оператор.

Как организовать такой стек? получается, что каждая вершина стека это указатель на аргумент или на вершину стека. У меня стек растет вверх. 

Допустим у меня есть выражение 2 3 +, которое нужно вычилить.
последовательность действий
1) находим переменные 2 или 3.
2) случайным образом выбираем, допустим 2.
3) находим определение 2 , которое загружено в стек определений,
4) а стек определений выглядит как 1 1 + который ссылается имя в таблице имен "2"
5) Создаем новый стек 1 1 + и делаем на него ссылку из вычисляемого примера,
6) в результате у нас получается 2 стека: 1 1 + X : и X 3 +
7) Теперь нужно найти перестановочный закон, который должен быть загружен в некоторое количество стеков, например A B + C + A B C + + ==
То есть это правило должно быть записано как
A B + X :
X C + Y :
A X0 + Z :
B C + X0 :

Y должен ссылаться на Z, а Z ссылаться на Y.

По видимому не получается сделать так. Видимо нужно разворачивать все в одном стеке, то есть все операторы должны быть загружены в стек.
применение перестановочного закона должно быть сделано к нескольким переменным, которые должны образовывать паттерн.
То есть чтобы применить паттерн надо найти соответсвие между стеком или фрагментом стека и паттерном. 
Перед применением паттерна вынести фрагменты в отдельные стеки.

Получается, стек должен поедставлять собой последовательность ячеек, которые представляют собой структуры. Каждая ячейка может хранить или оператор или выражение или символ.

1) Для стека надо сделать несколько операций, типа заменить элемент стека на фрагмент.
2) Вынять фрагмент стека и заменить его на указатель на выражение.
3) Найти правило в стеке (есть паттерн или нет)
4) Применить правило.
5) Пропарсить выражение, и поместить его в стек
6) прочитать стек и вывести выражение


Правила надо разбивать на паттерны, которые было бы легко искать в стеке.
Это должна делать функция 
7) Загрузка правил

8) Должна быть функция загрузки сигнатур операторов.
9) Функция загрузки знаков или определений. 

Структура отношений может быть типа "штаны". Два выражения определяются в 2 колошинах, а не вершине оператор отношения. 

Оператор отношения нужен для того, чтобы определить в какую сторону делать преобразование.

-----o--------o--------o------- отнощения
    / \      / \      / \     
---a---b----c---d----e---r----- ветки определений и правил.
   |   |    |   |    |   |

========================================================================
Отношение - это всегда определение зависимости между двумя частями.

Оператор может быть от 1,2,3 ... N аргументов.

Поэтому не имеет смысла записывать отношение в виде обратной польской записи.

Операторы отношений:
== эквивалентно
-> причина
<- следствие

A B -> == B A <-
A B C + + == A B + C +





