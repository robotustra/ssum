
Для описания операторов используется синтаксис типа
[X][Y]+
где [] обозначают выражение или простой объект.
Если же в описании стоит () то это простой объект (или имя объекта).

например
[X](Y)==

описание оператора, это его сигнатура и она определяет число аргументов у оператора.

Помимо сигнатуры оператор еще есть правила связи операторов, которые позволяют делать преобразования
по правилам.

Например, перестоновочный закон для оператора сложения выглядит так:
[x] [y] + [y] [x] + ==

Имя переменной в скобках рассматривается только в пределах одной строки.

если имя стоит в кавычках "", то это означает, для простого объекта, что берется его имя.
Если же объект это выражение, то сначала вычисляется значение этого объекта, а потом берется его имя.

Склеивание имен. Если нам необходимо склеить два имени объекта, то запись будет выглядеть "[X][Y]"

Вычитание имен. Если мы хотим разделить имя на 2 части, часть из которых известна, то нужно воспользоваться правилом

(X) (Y) -@
"[x][y]" "[y]" -@ "[x]" ==

оператор -@ отрезает имя справа, если оно имеется.

можно так же определить оператор -/. который разделяет имя на 2 части

(X) (Y) -/.
"[X][Y]" "[Y]" -/. "[X]" "[Y]" ==

Если имя объекта не известно, но нужно отделить один символ от имени объекта, нужно использовать имя "?"
для 2 символов "??" и так дале.

Если нужно повторить операцию несколько раз, то для этого нужно использовать операцию

x[N], где N воспринимается как целое число и при этом может быть использован как итератор в выражении.

F "?" -/. x[5] R ==

Это уравнение отрезает от имени 5 символов.
Для определения нового имени оператора из уже существующих можно использовать {} например

"[X]" "?" -/. x[N] {R5} ==

Определили новый оператор R5 который отрезает N символов от имени. 
Ну и так далее.

По сути дела интерпретатор должен находить определение оператора и уметь применять его. При этом применение будет делаться в случайной последовательности, а вектор, определяющий направление вычисления - это избавление от всех операторов, или сведение их числа к минимуму.

Нужен так же оператор счета параметров.
Какие-то операторы нужно будет ввести до того как их использовать, то есть это будут встроенные операторы
и они будут лежать в основе языка.


То есть интерпретатор должен различать:
1) сигнатуру функции
2) правила преобразования понятний (переменных)
3) связи или ограничения (на параметры) (определения)
4) функции более высокого порядка, построенные на более мелких или встроенных функциях и операторах.
5) Правила преобразования выражений (типа сочетательный закон и т.д.) или интерпретация.

Сама по себе программа должны представлять собой список правил, действий и отношений, который будет случайным образом преобразовывать входные отношения и достраивать оригинальный список.

Алгоритм движка должен быть таким:

находим терм уравнения (или группы уравнений) которую нужно решить и производим подстановку определения, действия или отношений 
производим оценку преобразования. если подобная комбинация уже встречалась, то она не принимается.

Если после некоторого числа операций невозможно уменьшить число операторов или все варианты приводят к ранее известными, то вычисление останавливается.


Встроенные операторы это "=="
смысл его означает тождественное преобразование одного выражения в другое.

Другой встроенный оператор "=>" означает однозначное преобразование одного выражения в другое.
==============

Для начала нужно вделять сигнатуры функции. В сигнатуре нужно различать аргументы, которые могут быть в квадратных скобках.

Что должна отражать сигнатура? Количество аргументов, которые могут быть или простыми именами или выражениями.
Может ли сигнатура функции быть типа такой:

[ X [Y] ] * и если может быть, то что она значит? Скорее всего сигнатура может быть немного другой, типа

[ X [Y] op1 ] op2   Но в таком случае непонятно зачем нужно описывать сигнатуру функции op1.

Поэтому сигнатуры могут описывать только 
1) простые параметры, которые должны браться в круглые скобки (X)

2) параметры, которые могут быть составными должны браться в квадратные скобки [Y]

3) Параметр простой, если он является вычисленным и представляет собой только имя.

4) Имя в свою очередь может быть представлено как результат вычисления некого выражения.

Все операции производятся над именами, просто составной параметр состоит из простых имен разделенных пробелами.

параметр или имя - это некое сочетание символов, которое имеет нулевун сигнатуру.
нулевая сигнатура описывается как 
[0] a

Обычно не нужно описывать простые параметры, поскольку они представляют собой само название. Величина параметра это и есть его имя.

Сам параметр (его имя) не несет никакого смысла, если не определены отношения этого параметра с другими параметрами.

Операции имеют сигнатуру, которая может быть определена через последовательность параметров. Эта сигнатура нужна для того, чтобы правильно парсить выражение.

Иногда для манипуляций с именем можно задать переменную, то есть переменная по сути дела может быть разименована, разыменование и есть вычисление ее имени из остальных отношений.

Переменные нужно как-то обозначить, их нужно отличать от простых имен.

Так как простые переменные могут содержать любые символы, то переменные должны содержать некий редко используемый символ, который может так же содержаться в имени, но как ескейп последовательность.

Например, если переменная должна заканчиваться на знак ? , то как определить например имя параметра использующее знак вопроса?

Так как я буду использовать все те символы, которые можно встретить на печати.

Для того, чтобы отличить переменную от константы после нее будет ставится модификатор "?"

То есть переменная X отличается от понятия X только тем, что после переменной стоит вопрос

[X] ?

Есть сигнатура переменной.

Если мы хотим задать выражение, то оно записывается как

2 4 + 5 * 20 / X ? ==

то есть по человечески это означает уравнение X = (2+4) *5 /20
для того, чтобы вычислить значение переменной нужно задать уравнение

X ?

А в уравнениях нужно просто использовать модификатор значения, который означает вычисление переменной и замену ее вычисленным выражением.
Такой модификатор будет !

правила действий такие 

[X] ? ! [X] ==

Что означает тогда правило если оно применено к простой переменной?

[X] !  

Пусть оно выводит определение параметра
Например:

если определено
 	3 2 + 5 ==
то 
5 ! выведет определение

3 2 +

и наоборот, 

3 2 + ! выведет
5

------------------------------------------------------------
2) правила преобразования понятний (переменных)




